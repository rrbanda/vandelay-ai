# =============================================================================
# Vandelay Search Agent Configuration
# =============================================================================
# Configuration for the FSI GraphRAG Agent.
#
# NOTE: Data ingestion settings (extraction, loading) have been moved to
#       data_ingestion/config.yaml
#
# Before running this agent, you must ingest data first:
#   python -m data_ingestion.ingest_graph --clear
#   python -m data_ingestion.ingest_vector --clear
# =============================================================================

# =============================================================================
# LLM Configuration
# =============================================================================
llm:
  model: "openai/gemini-llm/gemini-2.5-flash"
  api_base: "https://lss-lss.apps.cluster-nngf2.dynamic.redhatworkshops.io/v1/openai/v1"
  api_key: "not-needed"
  temperature: 0.1

# =============================================================================
# Neo4j Configuration
# =============================================================================
# IMPORTANT: Set credentials via environment variables for security:
#   export NEO4J_URI="bolt://your-server:7687"
#   export NEO4J_USERNAME="neo4j"
#   export NEO4J_PASSWORD="your-secure-password"
#
# Environment variables ALWAYS override values below (see config_loader.py).
# The values below are defaults for local development only.
neo4j:
  uri: "bolt://localhost:7687"
  username: "neo4j"
  # DO NOT commit real passwords. Set NEO4J_PASSWORD environment variable.
  password: ""

# =============================================================================
# LlamaStack Vector Store Configuration
# =============================================================================
# Environment variable overrides:
#   LLAMASTACK_BASE_URL - Vector store API base URL
#   VECTOR_STORE_ID - Vector store identifier
#   VECTOR_STORE_VERIFY_SSL - Set to 'false' only for dev with self-signed certs
#   VECTOR_STORE_SEARCH_MODE - Search mode: 'vector', 'keyword', or 'hybrid'
vector_store:
  provider: "llamastack"
  base_url: "https://lss-lss.apps.cluster-nngf2.dynamic.redhatworkshops.io"
  vector_store_id: "vs_46cdaac0-e4f5-45ef-9e2c-3689b672092c"
  vector_store_name: "acme-bank-docs"
  embedding_model: "sentence-transformers/all-MiniLM-L6-v2"
  embedding_dimension: 384
  similarity_top_k: 5
  # SSL verification: true for production security, false only for dev with self-signed certs
  verify_ssl: false  # TODO: Set to true for production
  
  # Hybrid Search Configuration (LlamaStack enhanced features)
  # search_mode: 'vector' (semantic only), 'keyword' (exact match), 'hybrid' (both)
  search_mode: "hybrid"
  
  # Ranking options for hybrid search
  # ranker_type: 'rrf' (Reciprocal Rank Fusion) or 'weighted'
  # ranking_alpha: Weight for vector vs keyword (0.0-1.0, higher = more vector weight)
  #   - 0.7 means 70% vector similarity, 30% keyword matching
  #   - 1.0 means pure vector search
  #   - 0.0 means pure keyword search
  ranker_type: "weighted"
  ranking_alpha: 0.7

# =============================================================================
# GraphRAG Configuration (Hybrid Vector-Graph Retrieval)
# =============================================================================
# Entity patterns used to extract mentions from vector search results
# and link them to the knowledge graph. This enables the core GraphRAG pattern:
# Vector Search -> Entity Extraction -> Graph Context Expansion
graphrag:
  # Enable/disable graph context expansion in hybrid retrieval
  enable_graph_context: true
  
  # Maximum entities to look up in graph per query
  max_entity_lookups: 10
  
  # Maximum graph connections to return per entity
  max_connections_per_entity: 5
  
  # FSI domain entity patterns for extraction from text
  entity_patterns:
    products:
      - "checking"
      - "savings"
      - "money market"
      - "certificate of deposit"
      - "cd"
      - "mortgage"
      - "home equity"
      - "heloc"
      - "personal loan"
      - "auto loan"
      - "credit card"
      - "rewards card"
      - "secured card"
      - "business loan"
      - "line of credit"
    
    regulations:
      - "basel iii"
      - "basel 3"
      - "aml"
      - "anti-money laundering"
      - "kyc"
      - "know your customer"
      - "dodd-frank"
      - "gdpr"
      - "sox"
      - "sarbanes-oxley"
      - "pci dss"
      - "glba"
      - "gramm-leach-bliley"
      - "bsa"
      - "bank secrecy act"
    
    risk_terms:
      - "credit risk"
      - "market risk"
      - "operational risk"
      - "liquidity risk"
      - "counterparty risk"
      - "counterparty"
      - "portfolio"
      - "exposure"
      - "capital requirement"
      - "risk factor"
      - "mitigation"
      - "var"
      - "value at risk"
    
    compliance_terms:
      - "compliance"
      - "regulatory"
      - "penalty"
      - "sanction"
      - "audit"
      - "suspicious activity"
      - "sar"
      - "ctr"
      - "currency transaction"

# =============================================================================
# Orchestrator Agent
# =============================================================================
orchestrator:
  name: "vandelay_search"
  description: "Vandelay Financial Corporation AI Assistant - Products, Compliance & Risk"
  
  instruction: |
    You are the Vandelay Financial Corporation AI Assistant, helping with banking products, compliance, and risk questions.
    
    You coordinate specialized sub-agents using the AGENTIC GRAPHRAG pattern - combining semantic search with knowledge graph context.
    
    ## GraphRAG Retrieval Strategy
    
    The vector_search_agent now includes HYBRID GRAPHRAG retrieval that automatically:
    1. Searches documents semantically
    2. Extracts entity mentions (products, regulations, risks)
    3. Fetches related graph context for those entities
    
    This gives you richer context combining document content with structured knowledge graph relationships.
    
    ## Sub-Agents Available
    
    1. **vector_search_agent** - PREFERRED for explanatory questions (includes GraphRAG)
       
       Has two tools:
       - `vector_search_docs`: Basic semantic search on documents
       - `vector_search_with_graph_context`: HYBRID GRAPHRAG - searches docs AND fetches related graph context
       
       Use for:
       - "What is Basel III?" -> Gets docs + regulation requirements from graph
       - "Explain credit risk assessment" -> Gets docs + portfolio/risk graph connections
       - "What are the AML compliance procedures?" -> Gets policy docs + regulation details
       - "How do mortgage products work?" -> Gets product guides + product graph details
    
    2. **graph_query_agent** - For direct entity lookups and structured data:
       - "List all customers" (entity list)
       - "Which customers are high risk?" (filtered entities)
       - "What products does the bank offer?" (entity list)
       - "Show me transactions for customer X" (relationship query)
       - "What accounts does Sarah Chen have?" (specific entity lookup)
    
    3. **cypher_expert_agent** - For complex analysis queries:
       - "Show the graph schema"
       - "Find all products with annual fees over $100"
       - "What penalties exist for non-compliance?"
    
    4. **answer_critic_agent** - For validating answer quality:
       - Evaluates if retrieved information fully answers the question
       - Returns completeness_score (0-100) and recommendation
       - Generates follow-up queries if information is incomplete
    
    ## Routing Guidelines (GraphRAG Pattern)
    
    ### Use vector_search_agent (with GraphRAG) for:
    - "What is X?" or "Explain X" or "How does X work?"
    - Questions about policies, procedures, requirements
    - Questions mentioning specific entities (Basel III, credit cards, etc.)
    
    The hybrid tool automatically enriches results with graph context when entities are mentioned.
    
    ### Use graph_query_agent for:
    - "List all X" or "Which X are Y?" or "Show me X"
    - Direct entity lookups without explanation needed
    - Specific data retrieval (accounts, transactions, etc.)
    
    ### Use cypher_expert_agent for:
    - Complex aggregations or comparisons
    - Multi-hop graph traversals
    - Custom analysis queries
    
    ## Answer Validation Loop
    
    After receiving results from retriever agents:
    
    1. Route question to appropriate agent (prefer vector_search_agent with GraphRAG for explanatory questions)
    2. Review the returned graph_context along with documents
    3. Call answer_critic_agent to validate completeness
    4. If incomplete, call graph_query_agent for additional entity details
    5. Synthesize final response combining all sources
    
    ## Important Rules
    
    - PREFER vector_search_with_graph_context for questions about concepts/policies - it includes graph context automatically
    - Use graph_query_agent when you need direct entity lookups or the hybrid tool didn't find relevant entities
    - ALWAYS evaluate with answer_critic after retrieval
    - NEVER loop more than 3 times
    - Always be helpful and professional

# =============================================================================
# Sub-Agents Configuration
# =============================================================================
sub_agents:
  vector_search:
    name: "vector_search_agent"
    description: "GraphRAG semantic search with knowledge graph context expansion"
    instruction: |
      You are a Banking Knowledge specialist for Vandelay Financial Corporation.
      
      Your job: Find relevant information using HYBRID GRAPHRAG retrieval - combining 
      semantic document search with knowledge graph context.
      
      ## Tools Available
      
      1. `vector_search_with_graph_context` (PREFERRED - GraphRAG hybrid retrieval)
         - Uses HYBRID SEARCH (vector + keyword) for better recall
         - Automatically extracts entity mentions (products, regulations, risks)
         - Fetches related graph context for mentioned entities
         - Returns: documents + entities_mentioned + graph_context
         
         Use this for most queries - it gives richer context.
      
      2. `vector_search_docs` (Hybrid search without graph expansion)
         - Uses HYBRID SEARCH (vector + keyword) combining semantic and exact matching
         - Good for queries with specific terms (Basel III, AML, etc.)
         - Use when you only need document content
      
      ## Hybrid Search Benefits
      Both tools now use hybrid search by default, which combines:
      - **Vector search**: Semantic similarity (understands meaning)
      - **Keyword search**: Exact term matching (catches specific terms like "Basel III")
      
      This is especially useful for FSI domain queries with regulatory terms.
      
      ## Document Types Available
      - Account types guide (checking, savings, CDs)
      - Loan products guide (mortgages, personal loans, auto loans)
      - Credit cards guide (rewards, travel, secured)
      - Banking FAQs and how-to guides
      - AML compliance policy (anti-money laundering)
      - Basel III overview (capital requirements)
      - Credit risk assessment (portfolios, counterparties)
      
      ## GraphRAG Response Format
      
      When using `vector_search_with_graph_context`, you'll receive:
      - `documents`: Matching document chunks with content and scores
      - `entities_mentioned`: Entities detected in the documents (e.g., "basel iii", "credit card")
      - `graph_context`: Related information from the knowledge graph for those entities
      
      Use BOTH the document content AND graph context to provide comprehensive answers.
      
      ## Guidelines
      - PREFER `vector_search_with_graph_context` for questions mentioning banking entities
      - Include information from both documents and graph context in your answers
      - Mention which document the information comes from
      - Reference related entities from the graph context when relevant

  graph_query:
    name: "graph_query_agent"
    description: "Structured queries on products, regulations, and risk data"
    instruction: |
      You are an FSI Knowledge Graph specialist for Vandelay Financial Corporation.
      
      Your job: Query structured data about products, regulations, and risk.
      
      ## Graph Schema
      
      ### Node Types
      - Bank: The bank entity
      - Product: Financial products (checking, savings, loans, credit cards)
      - Fee, Feature, Reward, Requirement: Product components
      - Regulation: Financial regulations (Basel III, AML, KYC)
      - RegulatoryRequirement, RiskIndicator, Penalty: Regulation components
      - Portfolio, Counterparty, RiskFactor, MitigationStrategy: Risk entities
      - Document: Source documents
      
      ### Key Relationships
      - (Bank)-[:OFFERS]->(Product)
      - (Bank)-[:COMPLIES_WITH]->(Regulation)
      - (Bank)-[:OWNS]->(Portfolio)
      - (*)-[:EXTRACTED_FROM]->(Document)
      
      ## Available Tools
      - get_all_products, get_products_by_category, get_product_details
      - get_all_regulations, get_regulation_details, get_regulatory_requirements
      - get_all_portfolios, get_portfolio_details, get_high_risk_portfolios
      - get_graph_schema, run_cypher_query

  cypher_expert:
    name: "cypher_expert_agent"
    description: "Complex Cypher queries for custom analysis"
    instruction: |
      You are a Cypher Query expert for Vandelay Financial Corporation's FSI Knowledge Graph.
      
      Your job: Write and execute complex Cypher queries for custom analysis.
      
      ## CRITICAL: Always Get Schema First!
      
      ALWAYS call `get_graph_schema` or `get_graph_schema_text` FIRST before writing ANY query!
      This gives you the exact node labels, property names, and relationships available.
      Do NOT guess at property names or labels - use only what the schema shows.
      
      ## Tools Available
      
      - `get_graph_schema`: Returns structured schema (JSON format with labels, attributes, relationships)
      - `get_graph_schema_text`: Returns human-readable schema text
      - `run_cypher_query`: Execute a Cypher query (includes validation and retry)
      - `get_node_count`: Quick count of nodes by label
      
      ## FSI Domain Knowledge
      
      Standard node types in this graph:
      - Bank, Product, Fee, Feature, Reward, Requirement
      - Regulation, RegulatoryRequirement, RiskIndicator, Penalty
      - Portfolio, Counterparty, RiskFactor, MitigationStrategy
      - Customer, Account, Transaction, Document
      
      Standard relationships:
      - (Bank)-[:OFFERS]->(Product)
      - (Bank)-[:COMPLIES_WITH]->(Regulation)
      - (Bank)-[:OWNS]->(Portfolio)
      - (Product)-[:HAS_FEE]->(Fee), [:HAS_FEATURE]->(Feature), [:HAS_REWARD]->(Reward)
      - (Regulation)-[:HAS_REQUIREMENT]->(RegulatoryRequirement)
      - (Portfolio)-[:HAS_RISK_FACTOR]->(RiskFactor), [:MITIGATED_BY]->(MitigationStrategy)
      - (Customer)-[:OWNS]->(Account), [:HAS_TRANSACTION]->(Transaction)
      - (*)-[:EXTRACTED_FROM]->(Document)
      
      ## Query Best Practices
      
      1. NEVER return embedding/vector properties - they are large arrays that cause errors
      2. ALWAYS use LIMIT to prevent huge results (the tool adds LIMIT 100 if missing)
      3. Use OPTIONAL MATCH for relationships that may not exist
      4. Use collect() for aggregating related entities
      5. Use toLower() for case-insensitive matching
      6. Use parameterized syntax: $paramName (not {paramName})
      
      ## Error Handling
      
      If a query fails:
      1. Check the error message for hints (unknown label, unknown property, syntax error)
      2. Call get_graph_schema to verify labels and property names
      3. Retry with corrected query (up to 3 attempts)
      4. If still failing, explain the issue and suggest alternatives
      
      ## Example Queries
      
      Count high-risk customers:
      ```cypher
      MATCH (c:Customer) WHERE c.risk_level IN ['High', 'Critical'] RETURN count(c) as count
      ```
      
      Find products with fees over a threshold:
      ```cypher
      MATCH (p:Product)-[:HAS_FEE]->(f:Fee)
      WHERE f.amount > 50
      RETURN p.name, f.name, f.amount
      ORDER BY f.amount DESC LIMIT 20
      ```
      
      Get portfolio risk summary:
      ```cypher
      MATCH (p:Portfolio)
      OPTIONAL MATCH (p)-[:HAS_RISK_FACTOR]->(rf:RiskFactor)
      RETURN p.name, p.risk_score, collect(rf.name) as risk_factors
      ORDER BY p.risk_score DESC LIMIT 10
      ```

# =============================================================================
# Answer Critic Sub-Agent
# =============================================================================
answer_critic:
  name: "answer_critic_agent"
  description: "Evaluates answer completeness and generates follow-up queries"
  
  thresholds:
    complete: 80
    partial: 60
    retry: 40
  
  instruction: |
    You are an Answer Quality Critic for Vandelay Financial Corporation's AI Assistant.
    
    Evaluate whether retrieved information fully answers the user's question.
    
    ## Scoring (0-100)
    - 90-100: Fully answered with comprehensive details
    - 70-89: Mostly answered, minor gaps
    - 50-69: Partially answered, significant gaps
    - 30-49: Tangentially related only
    - 0-29: Not answered at all
    
    ## Recommendations
    - "complete": Ready to answer (score >= 80)
    - "partial": Can answer with noted limitations (score 60-79)
    - "retry": Need more retrieval (score 40-59)
    - "escalate": Cannot answer (score < 40)
    
    ## Output Format
    Return a JSON object with completeness_score, recommendation, 
    missing_information, follow_up_queries, and caveats.

# =============================================================================
# Agentic RAG Loop Configuration
# =============================================================================
agentic_loop:
  max_iterations: 3
  enable_critic: true
  enable_quick_check: true
  quick_check_min_results: 1
  
  routing_hints:
    checking: "get_products_by_category"
    savings: "get_products_by_category"
    mortgage: "get_products_by_category"
    credit card: "get_products_by_category"
    loan: "get_products_by_category"
    fees: "get_product_with_fees"
    basel: "get_regulation_requirements"
    aml: "get_regulation_requirements"
    kyc: "get_regulation_requirements"
    compliance: "get_compliance_status"
    penalty: "get_compliance_penalties"
    portfolio: "get_portfolio_risks"
    risk: "get_high_risk_items"
    counterparty: "get_counterparty_exposure"
    default: "vector_search_docs"

# =============================================================================
# Specialized Cypher Tools
# =============================================================================
specialized_tools:
  get_products_by_category:
    description: "Get products filtered by category"
    cypher: |
      MATCH (p:Product)
      WHERE toLower(p.category) CONTAINS toLower($category)
         OR toLower(p.subcategory) CONTAINS toLower($category)
      OPTIONAL MATCH (p)-[:HAS_FEE]->(f:Fee)
      RETURN p.name as name, p.category as category, p.subcategory as subcategory,
             p.interest_rate_apy as apy, p.interest_rate_apr as apr,
             p.minimum_balance as min_balance, p.best_for as best_for,
             collect(DISTINCT {fee: f.name, amount: f.amount}) as fees
      ORDER BY p.name
    parameters:
      - name: category
        type: string
        required: true
  
  get_product_with_fees:
    description: "Get full product details including fees, features, and requirements"
    cypher: |
      MATCH (p:Product)
      WHERE toLower(p.name) CONTAINS toLower($product_name)
      OPTIONAL MATCH (p)-[:HAS_FEE]->(f:Fee)
      OPTIONAL MATCH (p)-[:HAS_FEATURE]->(feat:Feature)
      OPTIONAL MATCH (p)-[:HAS_REWARD]->(r:Reward)
      OPTIONAL MATCH (p)-[:REQUIRES]->(req:Requirement)
      RETURN p {.*} as product,
             collect(DISTINCT f {.*}) as fees,
             collect(DISTINCT feat {.*}) as features,
             collect(DISTINCT r {.*}) as rewards,
             collect(DISTINCT req {.*}) as requirements
    parameters:
      - name: product_name
        type: string
        required: true
  
  get_regulation_requirements:
    description: "Get regulatory requirements with thresholds"
    cypher: |
      MATCH (r:Regulation)
      WHERE toLower(r.name) CONTAINS toLower($regulation_name)
         OR toLower(r.full_name) CONTAINS toLower($regulation_name)
      OPTIONAL MATCH (r)-[:HAS_REQUIREMENT]->(req:RegulatoryRequirement)
      RETURN r.name as regulation, r.type as type, r.description as description,
             collect(req {.name, .category, .threshold_value, .applies_to}) as requirements
    parameters:
      - name: regulation_name
        type: string
        required: true
  
  get_compliance_penalties:
    description: "Get penalties for regulatory non-compliance"
    cypher: |
      MATCH (r:Regulation)-[:HAS_PENALTY]->(p:Penalty)
      RETURN r.name as regulation, p.name as penalty, p.type as penalty_type,
             p.amount as amount, p.severity as severity, p.description as description
      ORDER BY CASE p.severity WHEN 'Critical' THEN 1 WHEN 'High' THEN 2 ELSE 3 END
    parameters: []
  
  get_portfolio_risks:
    description: "Get portfolio risk factors and mitigation strategies"
    cypher: |
      MATCH (p:Portfolio)
      WHERE toLower(p.name) CONTAINS toLower($portfolio_name)
      OPTIONAL MATCH (p)-[:HAS_RISK_FACTOR]->(rf:RiskFactor)
      OPTIONAL MATCH (p)-[:MITIGATED_BY]->(ms:MitigationStrategy)
      RETURN p {.name, .type, .asset_class, .total_value, .risk_score, .risk_rating} as portfolio,
             collect(DISTINCT rf {.name, .severity}) as risk_factors,
             collect(DISTINCT ms {.name, .priority, .implementation_status}) as mitigations
    parameters:
      - name: portfolio_name
        type: string
        required: true
  
  get_high_risk_items:
    description: "Get all high-risk portfolios and counterparties"
    cypher: |
      MATCH (p:Portfolio)
      WHERE p.risk_rating IN ['High', 'Critical'] OR p.risk_score >= 60
      WITH collect(p {.name, .risk_score, .risk_rating}) as portfolios
      MATCH (c:Counterparty)
      WHERE c.risk_assessment IN ['High', 'Critical']
      RETURN portfolios, collect(c {.name, .total_exposure, .risk_assessment}) as counterparties
    parameters: []
  
  get_counterparty_exposure:
    description: "Get counterparty exposure information"
    cypher: |
      MATCH (c:Counterparty)
      WHERE $name IS NULL OR toLower(c.name) CONTAINS toLower($name)
      RETURN c.name as name, c.type as type, c.industry as industry,
             c.credit_rating as rating, c.total_exposure as exposure,
             c.risk_assessment as risk_level
      ORDER BY c.total_exposure DESC
    parameters:
      - name: name
        type: string
        required: false
  
  get_compliance_status:
    description: "Get bank compliance status with regulations"
    cypher: |
      MATCH (b:Bank)-[:COMPLIES_WITH]->(r:Regulation)
      OPTIONAL MATCH (r)-[:HAS_REQUIREMENT]->(req:RegulatoryRequirement)
      RETURN b.name as bank,
             collect(DISTINCT {regulation: r.name, type: r.type, requirements: count(req)}) as regulations
    parameters: []

# =============================================================================
# Memory Service Configuration
# =============================================================================
memory:
  provider: "inmemory"
  settings:
    auto_save_sessions: true
    preload_memories: true
    max_memories_per_query: 5
